\section{Generation of Critical Graphs}

In this section we describe algorithms for processing and generating critical canvases via computer search.

\subsection{Representation of Canvases}

The first step is deciding how to represent canvases in our algorithms. Recall that a canvas $T$ is a tuple 
$(G, S, L)$ where $G$ is a plane graph, $S$ is a subgraph of the outer face and $L$ is a list assignment for 
$G$ satisfying some conditions. Here, in each algorithm we will usually be working with one particular family of 
canvases at a time, for example cycle-canvases or path-canvases with a fixed size of cycle or path, so the 
information about the subgraph $S$ can be ``implicit'' in each different representation for each different algorithm
instead of working with a general representation that allows all canvases. Also, in some scenarios we will be 
working with conditions on the list assignment $L$ which are different from the ones in the definition of canvas.
In this section we intend to just expose some general ideas about how the representation of graphs in this context
can be done, which will be afterwards applied in different scenarios.

The most important thing to state is that we will not be interested in storing the list assignment $L$ at all. 
This is because there is a significant combinatorial explosion in the number of list assignments to be considered and
we are interested in the graphs themselves, not the list assignments. Also, most of the results
we will be using such as \ref{gluinglemma} or \ref{cyclechordtripodtheorem} are directly related to subgraphs
and not list assignments, and while they are in theory stated with respect to a fixed list assignment, it is more
useful in practice to not consider the list assignment at all. 

Thus, when we generate all critical canvases $(G, S, L)$, what we will actually be doing is generate all pairs $(G, S)$ 
such that there exists some list assignment $L$  so that $(G, S, L)$ is a critical canvas. In some scenarios, we will also
be interested in storing the prescribed size of the list assignment for each vertex: that is, we will be storing a tuple $(G, S, f)$
with $f : V(G) \rightarrow \mathbb{N}$ so that we will only be considering list assignments $L$ with $|L(v)| = f(v)$, but other
than that we will not store information about the actual list assignment. 

We store the information of the graph $G$ with an adjacency list. We will also be interested in storing the planar embedding of the graph:
to do so, we order the edges in the adjacency list of each vertex according to their clockwise order in the embedding (as in a
\emph{rotation system}). This information, together with the information of which vertices are in the outer face, is enough to reconstruct
the embedding. 

We will want to test when two canvases are isomorphic. More generally, we will want to have a canonical form for each canvas, so that
given a set of canvases $\mathcal{S}$ and a new canvas $T$, we can check whether there is a canvas isomorphic to $T$ in $\mathcal{S}$ by checking the 
presence of the corresponding canonical form of $T$ in an associative array with the canonical forms of the canvases in $\mathcal{S}$.


...

\subsection{Generation of Critical Cycle-Canvases}

Our algorithm for the generation of critical cycle-canvases is based on \ref{cyclechordtripodtheorem}. 
This theorem says that every critical cycle-canvas can either be decomposed into two smaller critical 
cycle-canvases through a chord in the outer face, it can be decomposed into a ``tripod'', a vertex $v$ 
with at least $3$ neighbors in $C$, and a smaller critical cycle-canvas contained in the only nonempty 
face incident with $v$. In these decompositions, it is possible that instead of a smaller critical canvas 
we get an empty canvas, which is technically not critical. \todo{check that all definitions of critical 
canvases are consistent with this}

This implies that we can generate all critical cycle-canvases from smaller cycle-canvases by gluing
cycle-canvases through outer face edges to get a canvas with a chord, or by adding a tripod to the
outside of a cycle-canvas. We then have to check whether the resulting canvas is indeed critical,
since the decomposition into two smaller critical cycle-canvases is a necessary but not sufficient condition
for criticality. We will see how to do this in Section 4. \todo{references for sections}.

\missingfigure{The three cases for generation of critical cycle-canvases}

\todo{figure for generation of critical cycle-canvases and references to figure}

If we are generating cycle-canvases with cycle length $\ell$, then a chord partitions
the cycle-canvas into two cycle-canvases of length $a$, $b$ with $a, b \geq 3$ and $a + b = \ell + 2$ (see figure (a)), so 
$a, b \leq \ell-1$ and therefore if we have generated all cycle-canvases with cycle length $< \ell$ we can generate
all cycle-canvases with cycle length $\ell$ with a chord. In the case of adding a tripod, though, if the vertex $v$ of
the tripod is adjacent to only three adjacent vertices in the outer face, then the smaller cycle-canvas has the same
cycle length as the larger cycle-canvas (see figure (c)).

In order to resolve this, what we do is first generate all the cycle-canvases obtained from cycle-canvases with smaller cycle size 
(as in figure (a) and (b)), enqueue the resulting critical canvases, and then process the canvases from the queue and add tripods 
to three consecutive vertices in all possible ways, enqueueing the new critical cycle-canvases that are found. Here is the description 
of the algorithm:

\begin{algorithm}[H]
\caption{Generation of Critical Cycle-Canvases.}
\SetAlgoLined
\SetKwComment{Comment}{/* }{ */}
\SetKwProg{Fn}{function}{}{end}
\Comment*[h]{Generate critical canvases of cycle size $\ell$, including empty one}

\Fn{generateCriticalCycleCanvases($\ell$)}{ 
	
	\For{$i = 3, \ldots, \ell-1$} {
		$S_i \gets \text{generateCriticalCycleCanvases}(i)$\;
	}
	$S \gets \{ \text{emptyCycle}(\ell) \}$\;
	
	\For{$a = 3, \ldots, \ell-1$} {
		$b \gets \ell-a+2$\;
		\For{$G_1 \in S_a$} {
			\For{$G_2 \in S_b$} {
				$T \gets \text{fuseChordSet}(G_1, G_2)$\; 
				\Comment*[r]{Set of cycle-canvases obtained by fusing $G_1$ and $G_2$ along outer cycle edges in all possible ways}
				\For{$G \in T$} {
					\If{$G \not\in S$ AND $\text{isCritical}(G)$} {	
						$S \gets S \cup \{G\}$\;
					}
				} 
			}
		}
	}
	\For{$k = 3, \ldots, \ell-1$} {
		\For{$G_1 \in S_k$} {
			$T \gets \text{addTripodSet}(G_1, \ell-k+3, 3)$\;
			\Comment*[r]{Set of cycle-canvases obtained by adding a tripod with $3$ neighbors in the outer face to get a cycle-canvas of length $\ell$ in all possible ways}
			\For{$G \in T$} {
				\If{$G \not\in S$ AND $\text{isCritical}(G)$} {	
					$S \gets S \cup \{G\}$\;
				}
			} 
		}
	}	
	$Q \gets \text{Queue}(S)$\; 
	\While{$Q \text{ is not empty}$} {
		$G_1 \gets \text{first}(Q)$\;
		$\text{dequeue}(Q)$\;
		$T \gets \text{addTripodSet}(G_1, 3, 3)$\;
		\For{$G \in T$} {
			\If{$G \not\in S$ AND $\text{isCritical}(G)$} {	
				$S \gets S \cup \{G\}$\;
				$\text{enqueue}(Q, G)$\;
			}
		} 
	}
	return $S$\;
}


\end{algorithm}

\todo{fix algorithm size}


Note that we only need to add tripods with $3$ adjacent neighbors since vertices with a larger number of neighbors in the
outer face can be obtained by first adding chords and then adding finally adding a tripod with $3$ neighbors. However, 
often we are interested in just generating chordless critical canvases. In that case, we do need to add tripods of all sizes.
The modified algorithm for chordless critical cycle-canvases is the following:

\begin{algorithm}[H]
\caption{Generation of Chordless Critical Cycle-Canvases.}
\SetAlgoLined
\SetKwComment{Comment}{/* }{ */}
\SetKwProg{Fn}{function}{}{end}
\Comment*[h]{Generate critical canvases of cycle size $\ell$, including empty one}

\Fn{generateCriticalCycleCanvases($\ell$)}{ 
	
	\For{$i = 3, \ldots, \ell-1$} {
		$S_i \gets \text{generateCriticalCycleCanvases}(i)$\;
	}
	$S \gets \{ \text{emptyCycle}(\ell) \}$\;
	\For{$k = 3, \ldots, \ell-1$} {
		\For{$j = 3, \ldots, \ell-k+3$} {
			\For{$G_1 \in S_k$} {
				$T \gets \text{addTripodSet}(G_1, \ell-k+3, j)$\;
				\For{$G \in T$} {
					\If{$G \not\in S$ AND $\text{isCritical}(G)$} {	
						$S \gets S \cup \{G\}$\;
					}
				} 
			}
		}
	}	
	$Q \gets \text{Queue}(S)$\; 
	\While{$Q \text{ is not empty}$} {
		$G_1 \gets \text{first}(Q)$\;
		$\text{dequeue}(Q)$\;
		$T \gets \text{addTripodSet}(G_1, 3, 3)$\;
		\For{$G \in T$} {
			\If{$G \not\in S$ AND $\text{isCritical}(G)$} {	
				$S \gets S \cup \{G\}$\;
				$\text{enqueue}(Q, G)$\;
			}
		} 
	}
	return $S$\;
}


\end{algorithm}


\subsection{Generation of Critical Wedges}

\todo{Generation of critical wedges: chord or tripod theorem, etc}

